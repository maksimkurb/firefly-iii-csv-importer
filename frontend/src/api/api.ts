/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface FireflyUser
 */
export interface FireflyUser {
    /**
     * 
     * @type {Array<GrantedAuthority>}
     * @memberof FireflyUser
     */
    'authorities': Array<GrantedAuthority>;
    /**
     * 
     * @type {number}
     * @memberof FireflyUser
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof FireflyUser
     */
    'username'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof FireflyUser
     */
    'attributes': { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof FireflyUser
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GrantedAuthority
 */
export interface GrantedAuthority {
    /**
     * 
     * @type {string}
     * @memberof GrantedAuthority
     */
    'authority'?: string;
}
/**
 * 
 * @export
 * @interface Import
 */
export interface Import {
    /**
     * 
     * @type {number}
     * @memberof Import
     */
    'importId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Import
     */
    'filename'?: string;
    /**
     * 
     * @type {number}
     * @memberof Import
     */
    'mappingConfigId': number;
    /**
     * 
     * @type {string}
     * @memberof Import
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Import
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Import
     */
    'finishedAt'?: string;
}
/**
 * 
 * @export
 * @interface MappingConfig
 */
export interface MappingConfig {
    /**
     * 
     * @type {number}
     * @memberof MappingConfig
     */
    'mappingConfigId'?: number;
    /**
     * 
     * @type {string}
     * @memberof MappingConfig
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MappingConfig
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof MappingConfig
     */
    'userId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MappingConfig
     */
    'global': boolean;
    /**
     * 
     * @type {MappingConfigSpec}
     * @memberof MappingConfig
     */
    'config': MappingConfigSpec;
    /**
     * 
     * @type {string}
     * @memberof MappingConfig
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof MappingConfig
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface MappingConfigSpec
 */
export interface MappingConfigSpec {
    /**
     * 
     * @type {boolean}
     * @memberof MappingConfigSpec
     */
    'applyRules': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MappingConfigSpec
     */
    'fireWebhooks': boolean;
    /**
     * 
     * @type {ValueSpecTransactionTypeProperty}
     * @memberof MappingConfigSpec
     */
    'type': ValueSpecTransactionTypeProperty;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'date': ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'amount': ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'description': ValueSpecString;
    /**
     * 
     * @type {ValueSpecInteger}
     * @memberof MappingConfigSpec
     */
    'currencyId'?: ValueSpecInteger;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'currencyCode'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'foreignAmount'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecInteger}
     * @memberof MappingConfigSpec
     */
    'foreignCurrencyId'?: ValueSpecInteger;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'foreignCurrencyCode'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecInteger}
     * @memberof MappingConfigSpec
     */
    'budgetId'?: ValueSpecInteger;
    /**
     * 
     * @type {ValueSpecInteger}
     * @memberof MappingConfigSpec
     */
    'categoryId'?: ValueSpecInteger;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'categoryName'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecInteger}
     * @memberof MappingConfigSpec
     */
    'sourceId'?: ValueSpecInteger;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'sourceName'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'destinationId'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'destinationName'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecInteger}
     * @memberof MappingConfigSpec
     */
    'piggyBankId'?: ValueSpecInteger;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'piggyBankName'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecInteger}
     * @memberof MappingConfigSpec
     */
    'billId'?: ValueSpecInteger;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'billName'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'tags'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'notes'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'internalReference'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'externalId'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'externalUrl'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecInteger}
     * @memberof MappingConfigSpec
     */
    'bunqPaymentId'?: ValueSpecInteger;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'sepaCc'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'sepaCtOp'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'sepaCtId'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'sepaDb'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'sepaCountry'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'sepaEp'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'sepaCi'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'sepaBatchId'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'interestDate'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'bookDate'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'processDate'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'dueDate'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'paymentDate'?: ValueSpecString;
    /**
     * 
     * @type {ValueSpecString}
     * @memberof MappingConfigSpec
     */
    'invoiceDate'?: ValueSpecString;
}
/**
 * 
 * @export
 * @interface RawTransaction
 */
export interface RawTransaction {
    /**
     * 
     * @type {number}
     * @memberof RawTransaction
     */
    'rawTransactionId'?: number;
    /**
     * 
     * @type {number}
     * @memberof RawTransaction
     */
    'importId'?: number;
    /**
     * 
     * @type {number}
     * @memberof RawTransaction
     */
    'fireflyTransactionId'?: number;
    /**
     * 
     * @type {number}
     * @memberof RawTransaction
     */
    'rowNumber'?: number;
    /**
     * 
     * @type {object}
     * @memberof RawTransaction
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface ScriptEvaluationRequest
 */
export interface ScriptEvaluationRequest {
    /**
     * 
     * @type {string}
     * @memberof ScriptEvaluationRequest
     */
    'script': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ScriptEvaluationRequest
     */
    'context': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ScriptEvaluationRequest
     */
    'resultType': ScriptEvaluationRequestResultTypeEnum;
}

export const ScriptEvaluationRequestResultTypeEnum = {
    String: 'String',
    Integer: 'Integer',
    Boolean: 'Boolean',
    Double: 'Double'
} as const;

export type ScriptEvaluationRequestResultTypeEnum = typeof ScriptEvaluationRequestResultTypeEnum[keyof typeof ScriptEvaluationRequestResultTypeEnum];

/**
 * 
 * @export
 * @interface ValueSpecInteger
 */
export interface ValueSpecInteger {
    /**
     * 
     * @type {number}
     * @memberof ValueSpecInteger
     */
    'constant'?: number;
    /**
     * 
     * @type {string}
     * @memberof ValueSpecInteger
     */
    'field'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ValueSpecInteger
     */
    'fieldTrimming'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ValueSpecInteger
     */
    'script'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ValueSpecInteger
     */
    'valid': boolean;
}
/**
 * 
 * @export
 * @interface ValueSpecString
 */
export interface ValueSpecString {
    /**
     * 
     * @type {string}
     * @memberof ValueSpecString
     */
    'constant'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValueSpecString
     */
    'field'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ValueSpecString
     */
    'fieldTrimming'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ValueSpecString
     */
    'script'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ValueSpecString
     */
    'valid': boolean;
}
/**
 * 
 * @export
 * @interface ValueSpecTransactionTypeProperty
 */
export interface ValueSpecTransactionTypeProperty {
    /**
     * 
     * @type {string}
     * @memberof ValueSpecTransactionTypeProperty
     */
    'constant'?: ValueSpecTransactionTypePropertyConstantEnum;
    /**
     * 
     * @type {string}
     * @memberof ValueSpecTransactionTypeProperty
     */
    'field'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ValueSpecTransactionTypeProperty
     */
    'fieldTrimming'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ValueSpecTransactionTypeProperty
     */
    'script'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ValueSpecTransactionTypeProperty
     */
    'valid': boolean;
}

export const ValueSpecTransactionTypePropertyConstantEnum = {
    Withdrawal: 'withdrawal',
    Deposit: 'deposit',
    Transfer: 'transfer',
    Reconciliation: 'reconciliation',
    OpeningBalance: 'opening balance'
} as const;

export type ValueSpecTransactionTypePropertyConstantEnum = typeof ValueSpecTransactionTypePropertyConstantEnum[keyof typeof ValueSpecTransactionTypePropertyConstantEnum];


/**
 * ImportControllerApi - axios parameter creator
 * @export
 */
export const ImportControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Import} _import 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1: async (_import: Import, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_import' is not null or undefined
            assertParamExists('create1', '_import', _import)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('create1', 'file', file)
            const localVarPath = `/api/imports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (_import !== undefined) { 
                localVarFormParams.append('import', new Blob([JSON.stringify(_import)], { type: "application/json", }));
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} importId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1: async (importId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            assertParamExists('delete1', 'importId', importId)
            const localVarPath = `/api/imports/{importId}`
                .replace(`{${"importId"}}`, encodeURIComponent(String(importId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} importId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        item: async (importId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            assertParamExists('item', 'importId', importId)
            const localVarPath = `/api/imports/{importId}`
                .replace(`{${"importId"}}`, encodeURIComponent(String(importId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} importId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTransactions: async (importId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            assertParamExists('itemTransactions', 'importId', importId)
            const localVarPath = `/api/imports/{importId}/transactions`
                .replace(`{${"importId"}}`, encodeURIComponent(String(importId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/imports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} importId 
         * @param {Import} _import 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1: async (importId: number, _import: Import, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importId' is not null or undefined
            assertParamExists('update1', 'importId', importId)
            // verify required parameter '_import' is not null or undefined
            assertParamExists('update1', '_import', _import)
            const localVarPath = `/api/imports/{importId}`
                .replace(`{${"importId"}}`, encodeURIComponent(String(importId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_import, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportControllerApi - functional programming interface
 * @export
 */
export const ImportControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Import} _import 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create1(_import: Import, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Import>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create1(_import, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} importId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete1(importId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete1(importId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} importId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async item(importId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Import>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.item(importId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} importId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemTransactions(importId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RawTransaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemTransactions(importId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Import>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} importId 
         * @param {Import} _import 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update1(importId: number, _import: Import, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Import>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update1(importId, _import, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImportControllerApi - factory interface
 * @export
 */
export const ImportControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Import} _import 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1(_import: Import, file: File, options?: any): AxiosPromise<Import> {
            return localVarFp.create1(_import, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} importId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(importId: number, options?: any): AxiosPromise<void> {
            return localVarFp.delete1(importId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} importId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        item(importId: number, options?: any): AxiosPromise<Import> {
            return localVarFp.item(importId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} importId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemTransactions(importId: number, options?: any): AxiosPromise<Array<RawTransaction>> {
            return localVarFp.itemTransactions(importId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list1(options?: any): AxiosPromise<Array<Import>> {
            return localVarFp.list1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} importId 
         * @param {Import} _import 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(importId: number, _import: Import, options?: any): AxiosPromise<Import> {
            return localVarFp.update1(importId, _import, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportControllerApi - object-oriented interface
 * @export
 * @class ImportControllerApi
 * @extends {BaseAPI}
 */
export class ImportControllerApi extends BaseAPI {
    /**
     * 
     * @param {Import} _import 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportControllerApi
     */
    public create1(_import: Import, file: File, options?: AxiosRequestConfig) {
        return ImportControllerApiFp(this.configuration).create1(_import, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} importId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportControllerApi
     */
    public delete1(importId: number, options?: AxiosRequestConfig) {
        return ImportControllerApiFp(this.configuration).delete1(importId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} importId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportControllerApi
     */
    public item(importId: number, options?: AxiosRequestConfig) {
        return ImportControllerApiFp(this.configuration).item(importId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} importId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportControllerApi
     */
    public itemTransactions(importId: number, options?: AxiosRequestConfig) {
        return ImportControllerApiFp(this.configuration).itemTransactions(importId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportControllerApi
     */
    public list1(options?: AxiosRequestConfig) {
        return ImportControllerApiFp(this.configuration).list1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} importId 
     * @param {Import} _import 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportControllerApi
     */
    public update1(importId: number, _import: Import, options?: AxiosRequestConfig) {
        return ImportControllerApiFp(this.configuration).update1(importId, _import, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InfoControllerApi - axios parameter creator
 * @export
 */
export const InfoControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFireflyInstanceUrl: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/info/firefly-instance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoControllerApi - functional programming interface
 * @export
 */
export const InfoControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFireflyInstanceUrl(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFireflyInstanceUrl(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InfoControllerApi - factory interface
 * @export
 */
export const InfoControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFireflyInstanceUrl(options?: any): AxiosPromise<string> {
            return localVarFp.getFireflyInstanceUrl(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoControllerApi - object-oriented interface
 * @export
 * @class InfoControllerApi
 * @extends {BaseAPI}
 */
export class InfoControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoControllerApi
     */
    public getFireflyInstanceUrl(options?: AxiosRequestConfig) {
        return InfoControllerApiFp(this.configuration).getFireflyInstanceUrl(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MapperControllerApi - axios parameter creator
 * @export
 */
export const MapperControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} mappingConfigId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (mappingConfigId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mappingConfigId' is not null or undefined
            assertParamExists('_delete', 'mappingConfigId', mappingConfigId)
            const localVarPath = `/api/mappers/{mappingConfigId}`
                .replace(`{${"mappingConfigId"}}`, encodeURIComponent(String(mappingConfigId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MappingConfig} mappingConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (mappingConfig: MappingConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mappingConfig' is not null or undefined
            assertParamExists('create', 'mappingConfig', mappingConfig)
            const localVarPath = `/api/mappers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mappingConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/mappers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} mappingConfigId 
         * @param {MappingConfig} mappingConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (mappingConfigId: number, mappingConfig: MappingConfig, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mappingConfigId' is not null or undefined
            assertParamExists('update', 'mappingConfigId', mappingConfigId)
            // verify required parameter 'mappingConfig' is not null or undefined
            assertParamExists('update', 'mappingConfig', mappingConfig)
            const localVarPath = `/api/mappers/{mappingConfigId}`
                .replace(`{${"mappingConfigId"}}`, encodeURIComponent(String(mappingConfigId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mappingConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MapperControllerApi - functional programming interface
 * @export
 */
export const MapperControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MapperControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} mappingConfigId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(mappingConfigId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(mappingConfigId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MappingConfig} mappingConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(mappingConfig: MappingConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MappingConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(mappingConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MappingConfig>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} mappingConfigId 
         * @param {MappingConfig} mappingConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(mappingConfigId: number, mappingConfig: MappingConfig, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MappingConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(mappingConfigId, mappingConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MapperControllerApi - factory interface
 * @export
 */
export const MapperControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MapperControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} mappingConfigId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(mappingConfigId: number, options?: any): AxiosPromise<void> {
            return localVarFp._delete(mappingConfigId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MappingConfig} mappingConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(mappingConfig: MappingConfig, options?: any): AxiosPromise<MappingConfig> {
            return localVarFp.create(mappingConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: any): AxiosPromise<Array<MappingConfig>> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} mappingConfigId 
         * @param {MappingConfig} mappingConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(mappingConfigId: number, mappingConfig: MappingConfig, options?: any): AxiosPromise<MappingConfig> {
            return localVarFp.update(mappingConfigId, mappingConfig, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MapperControllerApi - object-oriented interface
 * @export
 * @class MapperControllerApi
 * @extends {BaseAPI}
 */
export class MapperControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} mappingConfigId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MapperControllerApi
     */
    public _delete(mappingConfigId: number, options?: AxiosRequestConfig) {
        return MapperControllerApiFp(this.configuration)._delete(mappingConfigId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MappingConfig} mappingConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MapperControllerApi
     */
    public create(mappingConfig: MappingConfig, options?: AxiosRequestConfig) {
        return MapperControllerApiFp(this.configuration).create(mappingConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MapperControllerApi
     */
    public list(options?: AxiosRequestConfig) {
        return MapperControllerApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} mappingConfigId 
     * @param {MappingConfig} mappingConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MapperControllerApi
     */
    public update(mappingConfigId: number, mappingConfig: MappingConfig, options?: AxiosRequestConfig) {
        return MapperControllerApiFp(this.configuration).update(mappingConfigId, mappingConfig, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScriptControllerApi - axios parameter creator
 * @export
 */
export const ScriptControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ScriptEvaluationRequest} scriptEvaluationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandboxEvaluate: async (scriptEvaluationRequest: ScriptEvaluationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptEvaluationRequest' is not null or undefined
            assertParamExists('sandboxEvaluate', 'scriptEvaluationRequest', scriptEvaluationRequest)
            const localVarPath = `/api/scripts/eval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scriptEvaluationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScriptControllerApi - functional programming interface
 * @export
 */
export const ScriptControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScriptControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ScriptEvaluationRequest} scriptEvaluationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sandboxEvaluate(scriptEvaluationRequest: ScriptEvaluationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sandboxEvaluate(scriptEvaluationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScriptControllerApi - factory interface
 * @export
 */
export const ScriptControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScriptControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ScriptEvaluationRequest} scriptEvaluationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandboxEvaluate(scriptEvaluationRequest: ScriptEvaluationRequest, options?: any): AxiosPromise<object> {
            return localVarFp.sandboxEvaluate(scriptEvaluationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScriptControllerApi - object-oriented interface
 * @export
 * @class ScriptControllerApi
 * @extends {BaseAPI}
 */
export class ScriptControllerApi extends BaseAPI {
    /**
     * 
     * @param {ScriptEvaluationRequest} scriptEvaluationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptControllerApi
     */
    public sandboxEvaluate(scriptEvaluationRequest: ScriptEvaluationRequest, options?: AxiosRequestConfig) {
        return ScriptControllerApiFp(this.configuration).sandboxEvaluate(scriptEvaluationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FireflyUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): AxiosPromise<FireflyUser> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getCurrentUser(options?: AxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }
}


